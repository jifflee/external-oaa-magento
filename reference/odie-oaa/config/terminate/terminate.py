#!/usr/bin/env python3
"""
================================================================================
TERMINATION SCRIPT - Safe Provider Cleanup
================================================================================

PURPOSE:
    Safely removes OAA providers that were created by the ODIE-OAA connector.
    Reads the oaa_provider_ids.json file and deletes ONLY those providers.

SAFETY FEATURES:
    - DRY RUN by default (--execute required for actual deletion)
    - Multiple validation checkpoints before any deletion
    - Provider ID verification to prevent accidental deletion of other data
    - Detailed logging of all actions
    - Confirmation required for each provider OR batch confirmation
    - Deletion log saved for audit trail

USAGE:
    # Preview what would be deleted (SAFE - no changes)
    python terminate.py --dry-run

    # Execute deletion with confirmation prompts
    python terminate.py --execute

    # Execute with single batch confirmation (less interactive)
    python terminate.py --execute --batch

    # Use specific provider IDs file
    python terminate.py --ids-file ./output/oaa_provider_ids.json --dry-run

WARNING:
    This operation is IRREVERSIBLE. Deleted providers cannot be restored.
    Always run with --dry-run first to verify what will be deleted.

================================================================================
"""

import os
import sys
import json
import argparse
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Any, Optional

from dotenv import load_dotenv


class TerminationError(Exception):
    """Raised when termination cannot proceed safely."""
    pass


class TerminationScript:
    """
    Safe provider cleanup with multiple validation checkpoints.

    SAFETY MODEL:
        Checkpoint 1: File validation - verify oaa_provider_ids.json exists and is valid
        Checkpoint 2: Provider enumeration - show exactly what will be deleted
        Checkpoint 3: Veza connection - verify we can connect to the API
        Checkpoint 4: Provider verification - confirm each provider exists and matches our records
        Checkpoint 5: Final confirmation - explicit user consent before deletion
        Checkpoint 6: Post-deletion verification - confirm providers were actually deleted
    """

    def __init__(self, env_file: str = "./.env"):
        """Initialize termination script."""
        # Load environment
        env_path = Path(env_file)
        if env_path.exists():
            load_dotenv(env_path)

        self.veza_url = os.getenv("VEZA_URL", "")
        self.veza_api_key = os.getenv("VEZA_API_KEY", "")
        self.output_dir = os.getenv("OUTPUT_DIR", "./output")
        self.debug = False
        self._veza_client = None

        # Deletion log
        self.deletion_log = {
            "started_at": None,
            "completed_at": None,
            "mode": None,
            "source_file": None,
            "checkpoints_passed": [],
            "providers_targeted": [],
            "providers_deleted": [],
            "providers_failed": [],
            "providers_not_found": [],
            "errors": []
        }

    def get_veza_client(self):
        """Get or create Veza OAA client."""
        if self._veza_client is None:
            try:
                from oaaclient.client import OAAClient
                self._veza_client = OAAClient(
                    url=self.veza_url,
                    api_key=self.veza_api_key
                )
            except Exception as e:
                raise TerminationError(f"Failed to create Veza client: {e}")
        return self._veza_client

    # ==========================================================================
    # CHECKPOINT 1: File Validation
    # ==========================================================================
    def checkpoint_1_validate_file(self, ids_file: str) -> Dict[str, Any]:
        """
        CHECKPOINT 1: Validate the provider IDs file.

        Verifies:
        - File exists
        - File is valid JSON
        - File contains expected structure
        - File was generated by this connector

        Returns:
            Dict with provider data if valid, raises TerminationError otherwise
        """
        print("\n" + "="*70)
        print("CHECKPOINT 1: FILE VALIDATION")
        print("="*70)

        # Check file exists
        if not os.path.exists(ids_file):
            raise TerminationError(
                f"Provider IDs file not found: {ids_file}\n"
                "This file is created when you run: python run.py --push\n"
                "Cannot proceed without knowing which providers to delete."
            )

        print(f"  [OK] File exists: {ids_file}")

        # Parse JSON
        try:
            with open(ids_file, 'r') as f:
                data = json.load(f)
        except json.JSONDecodeError as e:
            raise TerminationError(f"Invalid JSON in {ids_file}: {e}")

        print(f"  [OK] Valid JSON format")

        # Validate structure
        required_fields = ["providers"]
        for field in required_fields:
            if field not in data:
                raise TerminationError(
                    f"Missing required field '{field}' in {ids_file}\n"
                    "This file may be corrupted or from a different version."
                )

        providers = data.get("providers", [])
        if not providers:
            raise TerminationError(
                f"No providers found in {ids_file}\n"
                "The file exists but contains no provider entries."
            )

        print(f"  [OK] Contains {len(providers)} provider(s)")

        # Validate each provider entry
        for i, provider in enumerate(providers):
            if not provider.get("name"):
                raise TerminationError(f"Provider {i+1} missing 'name' field")
            if not provider.get("id"):
                raise TerminationError(f"Provider {i+1} missing 'id' field")

        print(f"  [OK] All provider entries have required fields")

        # Show metadata
        if data.get("generated_at"):
            print(f"  [INFO] Generated: {data['generated_at']}")
        if data.get("veza_url"):
            print(f"  [INFO] Veza URL: {data['veza_url']}")
        if data.get("provider_prefix"):
            print(f"  [INFO] Provider prefix: {data['provider_prefix']}")

        self.deletion_log["checkpoints_passed"].append("1_file_validation")
        self.deletion_log["source_file"] = ids_file

        print("\n  CHECKPOINT 1 PASSED: File validation successful")
        return data

    # ==========================================================================
    # CHECKPOINT 2: Provider Enumeration
    # ==========================================================================
    def checkpoint_2_enumerate_providers(self, data: Dict[str, Any]) -> List[Dict]:
        """
        CHECKPOINT 2: List all providers that will be deleted.

        Shows exactly what will be removed for user review.
        """
        print("\n" + "="*70)
        print("CHECKPOINT 2: PROVIDER ENUMERATION")
        print("="*70)

        providers = data.get("providers", [])

        print(f"\n  The following {len(providers)} provider(s) are targeted for deletion:\n")
        print("  " + "-"*66)
        print(f"  {'#':<4} {'Provider Name':<35} {'Provider ID':<25}")
        print("  " + "-"*66)

        for i, provider in enumerate(providers, 1):
            name = provider.get("name", "UNKNOWN")
            pid = provider.get("id", "UNKNOWN")
            # Truncate for display
            name_display = name[:33] + ".." if len(name) > 35 else name
            pid_display = pid[:8] + "..." if len(pid) > 25 else pid
            print(f"  {i:<4} {name_display:<35} {pid_display:<25}")

            if provider.get("app_name"):
                print(f"       Application: {provider['app_name']}")
            if provider.get("app_id"):
                print(f"       App ID: {provider['app_id']}")

        print("  " + "-"*66)

        self.deletion_log["checkpoints_passed"].append("2_provider_enumeration")
        self.deletion_log["providers_targeted"] = [
            {"name": p.get("name"), "id": p.get("id")}
            for p in providers
        ]

        print("\n  CHECKPOINT 2 PASSED: Provider enumeration complete")
        return providers

    # ==========================================================================
    # CHECKPOINT 3: Veza Connection
    # ==========================================================================
    def checkpoint_3_verify_connection(self) -> bool:
        """
        CHECKPOINT 3: Verify connection to Veza API.

        Ensures we can communicate with Veza before attempting deletions.
        """
        print("\n" + "="*70)
        print("CHECKPOINT 3: VEZA CONNECTION VERIFICATION")
        print("="*70)

        # Check credentials configured
        if not self.veza_url:
            raise TerminationError(
                "VEZA_URL not configured.\n"
                "Set VEZA_URL in your .env file or environment."
            )
        print(f"  [OK] VEZA_URL: {self.veza_url}")

        if not self.veza_api_key:
            raise TerminationError(
                "VEZA_API_KEY not configured.\n"
                "Set VEZA_API_KEY in your .env file or environment."
            )
        print(f"  [OK] VEZA_API_KEY: {'*' * 8}...{self.veza_api_key[-4:]}")

        # Test connection
        print(f"  [INFO] Testing connection to Veza...")
        try:
            client = self.get_veza_client()
            # Simple API call to verify connectivity
            client.get_provider("__connection_test__")
            print(f"  [OK] Successfully connected to Veza API")
        except Exception as e:
            error_str = str(e)
            # Connection test returns None for non-existent provider, which is fine
            if "401" in error_str or "Unauthorized" in error_str:
                raise TerminationError(
                    f"Authentication failed - check your VEZA_API_KEY\n"
                    f"Error: {e}"
                )
            elif "404" in error_str or "not found" in error_str.lower():
                # This is actually OK - means the API responded
                print(f"  [OK] Successfully connected to Veza API")
            elif "timeout" in error_str.lower() or "connection" in error_str.lower():
                raise TerminationError(
                    f"Cannot connect to Veza at {self.veza_url}\n"
                    f"Error: {e}"
                )
            else:
                # Other errors might be OK - connection worked but query returned nothing
                print(f"  [OK] Connection established (API responsive)")

        self.deletion_log["checkpoints_passed"].append("3_veza_connection")

        print("\n  CHECKPOINT 3 PASSED: Veza connection verified")
        return True

    # ==========================================================================
    # CHECKPOINT 4: Provider Verification
    # ==========================================================================
    def checkpoint_4_verify_providers(self, providers: List[Dict]) -> Dict[str, Any]:
        """
        CHECKPOINT 4: Verify each provider exists and matches our records.

        This is a CRITICAL safety check. For each provider:
        1. Check it exists in Veza
        2. Verify the provider ID matches what we have on record
        3. Report any mismatches (DO NOT delete mismatched providers)

        Returns:
            Dict with verified, not_found, and mismatched providers
        """
        print("\n" + "="*70)
        print("CHECKPOINT 4: PROVIDER VERIFICATION (CRITICAL)")
        print("="*70)
        print("\n  Verifying each provider exists in Veza and matches our records...\n")

        client = self.get_veza_client()

        verified = []
        not_found = []
        mismatched = []

        for provider in providers:
            name = provider.get("name")
            expected_id = provider.get("id")

            print(f"  Checking: {name}")

            try:
                existing = client.get_provider(name)

                if existing is None:
                    print(f"    [NOT FOUND] Provider does not exist in Veza")
                    not_found.append(provider)
                    continue

                actual_id = existing.get("id")

                if actual_id != expected_id:
                    print(f"    [MISMATCH] ID mismatch - WILL NOT DELETE")
                    print(f"      Expected: {expected_id}")
                    print(f"      Actual:   {actual_id}")
                    print(f"      This provider may have been recreated by another process.")
                    mismatched.append({
                        "provider": provider,
                        "expected_id": expected_id,
                        "actual_id": actual_id
                    })
                else:
                    print(f"    [VERIFIED] ID matches: {actual_id[:8]}...")
                    verified.append(provider)

            except Exception as e:
                print(f"    [ERROR] Could not verify: {e}")
                self.deletion_log["errors"].append({
                    "provider": name,
                    "error": str(e),
                    "phase": "verification"
                })

        result = {
            "verified": verified,
            "not_found": not_found,
            "mismatched": mismatched
        }

        # Summary
        print("\n  " + "-"*66)
        print(f"  VERIFICATION SUMMARY:")
        print(f"    Verified (safe to delete): {len(verified)}")
        print(f"    Not found (already deleted?): {len(not_found)}")
        print(f"    Mismatched (WILL NOT delete): {len(mismatched)}")
        print("  " + "-"*66)

        if mismatched:
            print("\n  WARNING: Mismatched providers detected!")
            print("  These providers exist but have different IDs than our records.")
            print("  They may have been recreated by another process or user.")
            print("  For safety, these will NOT be deleted.")

        if not verified:
            print("\n  No providers verified for deletion.")
            if not_found:
                print("  All providers appear to have already been deleted.")

        self.deletion_log["checkpoints_passed"].append("4_provider_verification")
        self.deletion_log["providers_not_found"] = [p.get("name") for p in not_found]

        print("\n  CHECKPOINT 4 PASSED: Provider verification complete")
        return result

    # ==========================================================================
    # CHECKPOINT 5: Final Confirmation
    # ==========================================================================
    def checkpoint_5_confirm_deletion(
        self,
        verified: List[Dict],
        dry_run: bool,
        batch_mode: bool = False
    ) -> bool:
        """
        CHECKPOINT 5: Final user confirmation before deletion.

        Requires explicit user consent before proceeding.
        """
        print("\n" + "="*70)
        print("CHECKPOINT 5: FINAL CONFIRMATION")
        print("="*70)

        if dry_run:
            print("\n  MODE: DRY RUN (no changes will be made)")
            print("\n  The following providers WOULD be deleted:\n")
            for provider in verified:
                print(f"    - {provider.get('name')}")
            print(f"\n  Total: {len(verified)} provider(s)")
            print("\n  To execute deletion, run with --execute flag")
            self.deletion_log["mode"] = "dry_run"
            return False

        if not verified:
            print("\n  No providers to delete.")
            return False

        print("\n  MODE: EXECUTE (changes WILL be made)")
        print("\n  " + "!"*66)
        print("  !!! WARNING: THIS ACTION IS IRREVERSIBLE !!!")
        print("  " + "!"*66)
        print("\n  The following providers WILL BE PERMANENTLY DELETED:\n")

        for provider in verified:
            print(f"    - {provider.get('name')} (ID: {provider.get('id')[:8]}...)")

        print(f"\n  Total: {len(verified)} provider(s) will be deleted")
        print("\n  This will remove all data associated with these providers from Veza.")
        print("  This action cannot be undone.")

        if batch_mode:
            print("\n  Batch mode enabled - single confirmation for all providers.")
            prompt = f"\n  Type 'DELETE {len(verified)} PROVIDERS' to confirm: "
            expected = f"DELETE {len(verified)} PROVIDERS"
        else:
            prompt = "\n  Type 'DELETE' to confirm: "
            expected = "DELETE"

        try:
            response = input(prompt).strip()
        except (EOFError, KeyboardInterrupt):
            print("\n\n  Aborted by user.")
            return False

        if response != expected:
            print(f"\n  Confirmation failed. Expected '{expected}', got '{response}'")
            print("  Deletion cancelled.")
            return False

        self.deletion_log["checkpoints_passed"].append("5_final_confirmation")
        self.deletion_log["mode"] = "execute"

        print("\n  CHECKPOINT 5 PASSED: User confirmation received")
        return True

    # ==========================================================================
    # CHECKPOINT 6: Execute Deletion
    # ==========================================================================
    def checkpoint_6_execute_deletion(
        self,
        verified: List[Dict],
        batch_mode: bool = False
    ) -> Dict[str, Any]:
        """
        CHECKPOINT 6: Execute the deletion with per-provider confirmation.

        For each provider:
        1. Optionally ask for individual confirmation (unless batch mode)
        2. Delete the provider
        3. Verify deletion succeeded
        """
        print("\n" + "="*70)
        print("CHECKPOINT 6: EXECUTING DELETION")
        print("="*70)

        client = self.get_veza_client()
        deleted = []
        failed = []
        skipped = []

        for i, provider in enumerate(verified, 1):
            name = provider.get("name")
            pid = provider.get("id")

            print(f"\n  [{i}/{len(verified)}] Deleting: {name}")

            # Individual confirmation unless batch mode
            if not batch_mode:
                try:
                    confirm = input(f"    Confirm delete {name}? [y/N]: ").strip().lower()
                except (EOFError, KeyboardInterrupt):
                    print("\n    Skipping remaining providers...")
                    break

                if confirm != 'y':
                    print(f"    Skipped.")
                    skipped.append(provider)
                    continue

            # Execute deletion
            try:
                print(f"    Deleting provider ID: {pid[:8]}...")
                client.delete_provider(pid)
                print(f"    [DELETED] Successfully deleted {name}")
                deleted.append(provider)
                self.deletion_log["providers_deleted"].append({
                    "name": name,
                    "id": pid,
                    "deleted_at": datetime.now(timezone.utc).isoformat()
                })

            except Exception as e:
                error_msg = str(e)
                print(f"    [FAILED] Error deleting {name}: {error_msg}")
                failed.append({"provider": provider, "error": error_msg})
                self.deletion_log["providers_failed"].append({
                    "name": name,
                    "id": pid,
                    "error": error_msg
                })

        # Post-deletion verification
        print("\n  " + "-"*66)
        print("  POST-DELETION VERIFICATION:")

        for provider in deleted:
            name = provider.get("name")
            existing = client.get_provider(name)
            if existing is None:
                print(f"    [CONFIRMED] {name} no longer exists")
            else:
                print(f"    [WARNING] {name} may still exist (check Veza UI)")

        self.deletion_log["checkpoints_passed"].append("6_execute_deletion")

        result = {
            "deleted": deleted,
            "failed": failed,
            "skipped": skipped
        }

        print("\n  CHECKPOINT 6 COMPLETE: Deletion execution finished")
        return result

    # ==========================================================================
    # Main Execution
    # ==========================================================================
    def run(
        self,
        ids_file: str = None,
        dry_run: bool = True,
        batch_mode: bool = False
    ) -> Dict[str, Any]:
        """
        Execute the termination process with all safety checkpoints.

        Args:
            ids_file: Path to oaa_provider_ids.json (default: output/oaa_provider_ids.json)
            dry_run: If True, only show what would be deleted (default: True)
            batch_mode: If True, single confirmation for all providers

        Returns:
            Deletion log with all actions taken
        """
        self.deletion_log["started_at"] = datetime.now(timezone.utc).isoformat()

        # Default IDs file location
        if ids_file is None:
            ids_file = os.path.join(self.output_dir, "oaa_provider_ids.json")

        print("\n" + "="*70)
        print("ODIE-OAA TERMINATION SCRIPT")
        print("="*70)
        print(f"\nMode: {'DRY RUN' if dry_run else 'EXECUTE'}")
        print(f"Provider IDs file: {ids_file}")
        print(f"Batch mode: {'Yes' if batch_mode else 'No (individual confirmations)'}")

        if not dry_run:
            print("\n" + "!"*70)
            print("!!! CAUTION: EXECUTE MODE - PROVIDERS WILL BE PERMANENTLY DELETED !!!")
            print("!"*70)

        try:
            # Checkpoint 1: File validation
            data = self.checkpoint_1_validate_file(ids_file)

            # Checkpoint 2: Provider enumeration
            providers = self.checkpoint_2_enumerate_providers(data)

            # Checkpoint 3: Veza connection
            self.checkpoint_3_verify_connection()

            # Checkpoint 4: Provider verification
            verification = self.checkpoint_4_verify_providers(providers)
            verified = verification["verified"]

            # Checkpoint 5: Final confirmation
            proceed = self.checkpoint_5_confirm_deletion(verified, dry_run, batch_mode)

            if proceed and verified:
                # Checkpoint 6: Execute deletion
                result = self.checkpoint_6_execute_deletion(verified, batch_mode)

                # Final summary
                print("\n" + "="*70)
                print("TERMINATION COMPLETE")
                print("="*70)
                print(f"\n  Deleted: {len(result['deleted'])}")
                print(f"  Failed: {len(result['failed'])}")
                print(f"  Skipped: {len(result['skipped'])}")
                print(f"  Not found: {len(verification['not_found'])}")
                print(f"  Mismatched (protected): {len(verification['mismatched'])}")
            else:
                print("\n" + "="*70)
                print("TERMINATION " + ("DRY RUN COMPLETE" if dry_run else "CANCELLED"))
                print("="*70)

        except TerminationError as e:
            print(f"\n\nTERMINATION ABORTED: {e}")
            self.deletion_log["errors"].append({
                "error": str(e),
                "phase": "pre-flight"
            })

        except Exception as e:
            print(f"\n\nUNEXPECTED ERROR: {e}")
            self.deletion_log["errors"].append({
                "error": str(e),
                "phase": "unexpected"
            })
            if self.debug:
                import traceback
                traceback.print_exc()

        finally:
            self.deletion_log["completed_at"] = datetime.now(timezone.utc).isoformat()

            # Save deletion log
            log_path = self._save_deletion_log()
            if log_path:
                print(f"\n  Deletion log saved to: {log_path}")

        return self.deletion_log

    def _save_deletion_log(self) -> Optional[str]:
        """Save deletion log to output directory."""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            log_filename = f"deletion_log_{timestamp}.json"
            log_path = os.path.join(self.output_dir, log_filename)

            # Ensure output directory exists
            os.makedirs(self.output_dir, exist_ok=True)

            with open(log_path, 'w') as f:
                json.dump(self.deletion_log, f, indent=2, default=str)

            return log_path
        except Exception as e:
            print(f"  Warning: Could not save deletion log: {e}")
            return None


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="ODIE-OAA Termination Script - Safe provider cleanup",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
SAFETY CHECKPOINTS:
  1. File validation - verify oaa_provider_ids.json exists and is valid
  2. Provider enumeration - show exactly what will be deleted
  3. Veza connection - verify API connectivity
  4. Provider verification - confirm each provider exists and matches records
  5. Final confirmation - explicit user consent required
  6. Post-deletion verification - confirm providers were deleted

EXAMPLES:
  # Preview what would be deleted (SAFE)
  python terminate.py --dry-run

  # Execute deletion with per-provider confirmation
  python terminate.py --execute

  # Execute deletion with single batch confirmation
  python terminate.py --execute --batch
"""
    )

    parser.add_argument(
        "--env", "-e",
        default="./.env",
        help="Path to .env file (default: ./.env)"
    )
    parser.add_argument(
        "--ids-file",
        help="Path to oaa_provider_ids.json (default: ./output/oaa_provider_ids.json)"
    )

    # Mode selection (mutually exclusive)
    mode_group = parser.add_mutually_exclusive_group(required=True)
    mode_group.add_argument(
        "--dry-run",
        action="store_true",
        help="Preview what would be deleted (no changes made)"
    )
    mode_group.add_argument(
        "--execute",
        action="store_true",
        help="Actually delete the providers (IRREVERSIBLE)"
    )

    parser.add_argument(
        "--batch",
        action="store_true",
        help="Single confirmation for all providers (no per-provider prompts)"
    )
    parser.add_argument(
        "--debug",
        action="store_true",
        help="Enable debug output"
    )

    args = parser.parse_args()

    # Initialize and run
    terminator = TerminationScript(env_file=args.env)
    terminator.debug = args.debug

    terminator.run(
        ids_file=args.ids_file,
        dry_run=args.dry_run,
        batch_mode=args.batch
    )


if __name__ == "__main__":
    main()
